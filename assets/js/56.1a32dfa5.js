(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{645:function(t,e,r){"use strict";r.r(e);var n=r(4),o=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"react-开始"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-开始"}},[t._v("#")]),t._v(" react 开始")]),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"react-介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-介绍"}},[t._v("#")]),t._v(" react 介绍")]),t._v(" "),r("ul",[r("li",[r("ol",[r("li",[t._v("react 是干什么的？\n"),r("ul",[r("li",[t._v("前端框架,构建用户界面的 javascript 库。")])])])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("react 能干什么？\n"),r("ul",[r("li",[t._v("开发网站，单页面应用，手机 app")]),t._v(" "),r("li",[t._v("vue 和 react 几乎在使用上和原理上非常的相似，vue 最初就是借鉴的 react 思想开发的")])])])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("react 好处：\n"),r("ul",[r("li",[t._v("api 非常少，使用起来很简单，灵活。")]),t._v(" "),r("li",[t._v("react 函数式编程思想")])])])])])]),t._v(" "),r("h2",{attrs:{id:"react-原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-原理"}},[t._v("#")]),t._v(" react 原理")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("vue 单向数据流 != 数据单向绑定")])]),t._v(" "),r("li",[r("p",[t._v("react 和 vue 不同的地方：数据单向绑定的")])]),t._v(" "),r("li",[r("p",[t._v("【数据流例子说明：】\n父组件 变量 传递给 子组件 子组件可以修改传递过来的变量吗？不可以，为什么，因为数据流是单向的，也就是说从父级传递过来的数据，子组件只能用，不能改。")])]),t._v(" "),r("li",[r("p",[t._v("react【数据单向绑定】\n也就是说，他不能自动的监听到数据的变化，不能自动实现 vue 中数据双向绑定\n我们在 react 中要实现双向绑定，需要手动的设置 setState")])]),t._v(" "),r("li",[r("ol",[r("li",[t._v("数据单向绑定")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("数据流--单向数据流")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("基于函数和类运作的【函数组件和类组件】")])]),t._v(" "),r("ul",[r("li",[t._v("3.1. 官网的阅读【自学】"),r("a",{attrs:{href:"https://zh-hans.reactjs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("中文官网"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("3.2.文档 --\x3e 核心概念【初级的基础知识】--\x3e高级指引【中级】 --\x3eHOOK【高级用法】")]),t._v(" "),r("li",[t._v("3.3.项目结构")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"4"}},[r("li",[t._v("创建项目注意事项\n注意：如果你电脑上安装过 create-react-app 脚手架 需要卸载\nnpm unistall -g create-react-app")])])])]),t._v(" "),r("h1",{attrs:{id:"创建项目第一步-基本搭建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建项目第一步-基本搭建"}},[t._v("#")]),t._v(" 创建项目第一步 基本搭建")]),t._v(" "),r("p",[t._v("在创建之前，需要有一个 git 仓库，我们要把项目搭建到 git 中")]),t._v(" "),r("p",[t._v("查看 node 版本\nnode -v\n或\n使用 nvm 进行 node 版本安装与切换")]),t._v(" "),r("p",[t._v("1、node 版本\nnvm use v14\nNow using node v14.15.3 (npm v6.14.9)\nnode -v\nv14.15.3\n为了保证同步，选择 node 版本 14\n2、开始创建项目\nnpx create-react-app my-app\n官方标准命令，my-app 为项目名称\nnpx create-react-app scss-route-mobx\n....\n3、git 仓库提交\n这块你要进行 git 提交 主要在企业做项目就应该放到仓库中，如果企业没有，那自己也要弄个仓库，哪天在家改个东西，或像今年的疫情在家办公所以，只要远程仓库有代码，电脑就是另一个事了。\n4、cd scss-route-mobx 进入项目目录\n先进入到这个项目目录\n5、yarn eject 开启配置文件\n这时候先不着急启项目，先把配置文件开启就是 webpack 这些基础配置开启\n6、yarn start 启动项目\n这时候你再起项目。 算是勉强创建了一个项目")]),t._v(" "),r("p",[t._v('创建项目第二步 sass 安装\n1、sass 安装\nyarn add node-sass-chokidar\nyarn add npm-run-all\n2、修改 package.json\n"scripts": {\n"build-css": "node-sass-chokidar src/ -o src/",\n"watch-css": "npm run build-css && node-sass-chokidar src/ -o src/ --watch --recursive --use-polling --polling-interval 1000",\n"start-js": "node scripts/start.js",\n"start": "npm-run-all -p watch-css start-js",\n"build-js": "node scripts/build.js",\n"build": "npm-run-all build-css build-js",\n"test": "node scripts/test.js --env=jsdom"\n},\n创建项目第三步 yarn build 打包注意事项\n新建一个.env 文件与 package.json 同在根目录下\nGENERATE_SOURCEMAP=false\n以下三种路径\nPUBLIC_URL=https://www.a.com/\nPUBLIC_URL=./\nPUBLIC_URL=/\n启动成功并编译成功表示 react 项目创建成功\n至此 一个基本的 react 项目算是创建成功了')]),t._v(" "),r("p",[t._v("创建项目第四步 设置代理、nginx 路由配置、跨域处理\nsrc/setupProxy.js 创建文件")]),t._v(" "),r("p",[t._v("const { createProxyMiddleware } = require('http-proxy-middleware');\nmodule.exports = function(app) {\napp.use(\n'/home',createProxyMiddleware({\ntarget: 'https://#####.com/',\nchangeOrigin: true,\n})\n);\napp.use(\n'/wp-json',createProxyMiddleware({\ntarget: 'https://#####.cn/',\nchangeOrigin: true,\n})\n);\n};")]),t._v(" "),r("p",[t._v("以下是具体某个页面中使用\nobj = {\nmediareports:{\npage_number:'2',\npage_size:'10'\n}\n}\nconst cfg = this.state.mediareports;\nthis.getApi('/home/mediareports',cfg,{}).then((res)=>{\nconsole.log(res.data)\n})\nthis.getApi('/wp-json/wp/v2/posts',{},{}).then((res)=>{\nconsole.log(res.data)\n})")]),t._v(" "),r("p",[t._v("async getApi(url,cfg,headers){\nlet data = await axios.get(url,{params:cfg},\n{\nheaders: headers\n})\nreturn data;\n}")]),t._v(" "),r("p",[t._v("创建项目第五步 react react-router 路由\nreact 的文件目录是怎么样\n1、pubilc - index.html - favicon.ico - manifest.json\n移动 App 的配置文件,用于指定应用的显示名称、图标、入口页面等信息.\n2、src - components - alert\nindex.jsx - footer\nindex.jsx - nav\nindex.jsx\n比如：\n导航、弹出层、loading 加载动画、分页器等 - images\n凡事页面中"),r("img",{attrs:{src:""}}),t._v("标签使用的图片 - js\n页面中编写的 js 功能及开发文件 - store\nredux\nmobx\ncontext - styles\nimg/\ncss、less、scss - unit\njs 一些组件\n比如，\n如果不用 jq,自己封装一些 js 的方法\n如果手机端有活动页面都需要下载 app,同的 app 的判断\n如果有弹出去 js 等 - view\nhome\nindex.jsx\nabout\nindex.jsx\njoined\nindex.jsx\nlist.jsx\nother.jsx - other\n1、导入包\nyarn add react-router-dom;")]),t._v(" "),r("p",[t._v("PS:\nreact-router 和 react-router-dom")]),t._v(" "),r("p",[t._v("react-router: 实现了路由的核心功能。\nreact-router-dom: 基于 react-router，加入了在浏览器运行环境下的一些功能。")]),t._v(" "),r("p",[t._v("react-router-dom 是 react-router 的加强版呗")]),t._v(" "),r("p",[t._v("因为 React Native 也要路由系统呀。所以还有一个库叫 react-router-native，这个库也是基于 react-router 的，它类似 react-router-dom，加入了 React Native 运行环境下的一些功能。")]),t._v(" "),r("p",[t._v("react-router-dom\nreact-router-native")]),t._v(" "),r("p",[t._v("React BrowserRouter 和 HashRouter 的区别")]),t._v(" "),r("p",[t._v("BrowserRouter：h5 路由（history API）\nHashRouter：哈希路由")]),t._v(" "),r("p",[t._v("主要区别")]),t._v(" "),r("p",[t._v("BrowserRouter 和 HashRouter 都可以实现前端路由的功能")]),t._v(" "),r("p",[t._v("BrowserRouter 实现的是单页面的路由切换\nHashRouter 实现的是全局路由切换")]),t._v(" "),r("p",[t._v("从原理上")]),t._v(" "),r("p",[t._v("HashRouter 在路径中包含了#，相当于 HTML 的锚点定位。（# 符号的英文叫 hash，所以叫 HashRouter，和散列没关系哦））")]),t._v(" "),r("p",[t._v("而 BrowserRouter 使用的是 HTML5 的新特性 History，没有 HashRouter(锚点定位)那样通用，低版本浏览器可能不支持。")]),t._v(" "),r("p",[t._v("从用法上")]),t._v(" "),r("p",[t._v("BrowserRouter 进行组件跳转时可以传递任意参数实现组件间的通信，而 HashRouter 不能(除非手动拼接 URL 字符串)，因此一般配合 Redux 或 mobx 使用，实现组件间的数据通信。")]),t._v(" "),r("p",[t._v("2、新增加 Router.js 文件")]),t._v(" "),r("p",[t._v("import React from 'react';")]),t._v(" "),r("p",[t._v("import { BrowserRouter, HashRouter, Route, Link, Switch } from 'react-router-dom';")]),t._v(" "),r("p",[t._v("import App from './App.js';")]),t._v(" "),r("p",[t._v("const Router = () => (\n"),r("BrowserRouter",[r("App")],1),t._v("\n)\nexport default Router;\n3、修改 index.js")],1),t._v(" "),r("p",[t._v("原 App 换成")]),t._v(" "),r("p",[t._v("import Router from './Router';")]),t._v(" "),r("Router"),t._v(" "),r("p",[t._v("4、App.js")]),t._v(" "),r("p",[t._v("import React , { Componet } from 'react';\nimport { withRouter,NavLink,Switch,Redirect,Route} from 'react-router-dom';")]),t._v(" "),r("p",[t._v("import Home from './view/home';\nimport Input from './view/input';\nimport Event from './view/event';")]),t._v(" "),r("p",[t._v("class App extends Component {\nrender(){\nreturn (\n"),r("Switch",[r("Route",{attrs:{exact:"",path:"/",component:"{Home}"}}),t._v(" "),r("Route",{attrs:{path:"/input",component:"{Input}"}}),t._v(" "),r("Route",{attrs:{path:"/event",component:"{Event}"}})],1),t._v("\n);\n}\n}\nexport default App;\n5、新增页面")]),t._v(" "),r("p",[t._v("./view/home/index.jsx\n./view/input/index.jsx\n./view/event/index.jsx\n内容自定义")]),t._v(" "),r("p",[t._v("import { withRouter,NavLink,Switch,Redirect,Route} from 'react-router-dom';")]),t._v(" "),r("NavLink",{attrs:{to:"/"}},[t._v("首页")]),t._v(" "),r("NavLink",{attrs:{to:"/input"}},[t._v("表单")]),t._v(" "),r("NavLink",{attrs:{to:"/event"}},[t._v("事件")]),t._v(" "),r("p",[t._v("import React , { Component } from 'react';\nimport { withRouter,NavLink,Switch,Redirect,Route} from 'react-router-dom';\nclass View extends Component {\nrender(){\nreturn (\n<React.Fragment>")]),t._v(" "),r("div",{attrs:{className:"mian"}},[t._v("这是首页面")]),t._v(" "),r("NavLink",{attrs:{to:"/"}},[t._v("首页")]),r("br"),t._v(" "),r("NavLink",{attrs:{to:"/input"}},[t._v("表单")]),r("br"),t._v(" "),r("NavLink",{attrs:{to:"/event"}},[t._v("事件")]),t._v(" "),t._v('\n)\n}\n}\nexport default View;\n创建项目第六步 mobx\n1、安装\nyarn add mobx\nyarn add mobx-react\n2、新建/src/store/store.js\nimport {observable, computed, action, autorun,runInAction} from \'mobx\';\n// import {observable, computed, action} from \'mobx\';\nclass Store {\n@observable tradeCfg = {\n\'sadf\':\'sadf\'\n};\n@observable baseInfo = {};\n@observable callback = null;\n@observable token = [\n{\n"id":1,\n"name":"YD"\n},\n{\n"id":2,\n"name":"ETH"\n}\n];\n}\n'),r("p",[t._v("export default Store;\nRouter.js 新增加如下代码\nimport { Provider } from 'mobx-react';\nimport { observable, useStrict ,autorun} from 'mobx';")]),t._v(" "),r("p",[t._v("import App from './App.js';\nimport firstStore from './store/first';\n// const cnstore = new cnStore();\nconst stores = {\nfirst: new firstStore(),\n// ...other stores\n};")]),t._v(" "),r("Provider",{attrs:{"{...stores}":""}},[r("App")],1),t._v(" "),r("p",[t._v("完整代码如下：\nimport React from 'react';")]),t._v(" "),r("p",[t._v("import { BrowserRouter, HashRouter, Route, Link, Switch } from 'react-router-dom';\nimport { Provider } from 'mobx-react';\nimport { observable, useStrict ,autorun} from 'mobx';")]),t._v(" "),r("p",[t._v("import App from './App.js';\nimport firstStore from './store/store';\n// const cnstore = new cnStore();\nconst stores = {\nfirst: new firstStore(),\n// ...other stores\n};")]),t._v(" "),r("p",[t._v("const Router = () => (\n"),r("BrowserRouter",[t._v("\n<Provider {...stores}>\n"),r("App")],1),t._v("\n)\nexport default Router;\nmobx 报错\nSyntaxError: /Users/hello/workspace/fe.youdeal.io/app/my-app/src/store/otc.js: Support for the experimental syntax 'decorators-legacy' isn't currently enabled (3:5):")],1),t._v(" "),r("p",[t._v("1 | import {observable, computed, action} from 'mobx';\n2 | class Store {")]),t._v(" "),r("blockquote",[r("p",[t._v("3 | @observable tradeCfg = {")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("|     ^\n")])])]),r("p",[t._v("4 | 'sadf':'sadf'\n5 | };\n6 | @observable baseInfo = {};")]),t._v(" "),r("p",[t._v('以上问题 需安装\nyarn add @babel/plugin-proposal-decorators\nyarn add @babel/plugin-proposal-class-properties\n需添加代码 package.json\n"presets": [\n["react-app"],\n["@babel/preset-react"]\n],\n"plugins": [\n["@babel/plugin-proposal-decorators", {"legacy": true }],\n["@babel/plugin-proposal-class-properties", { "loose" : true }]\n]\nevent 页面调整\nimport React , { Component } from \'react\';\nimport { withRouter,NavLink,Switch,Redirect,Route} from \'react-router-dom\';')]),t._v(" "),r("p",[t._v("import {observer,inject} from 'mobx-react';\n// 导入需要的模块\n@withRouter\n@inject('first')\n@observer\nclass View extends Component {\nrender(){\nconsole.log(this.props.first)\nreturn (\n<React.Fragment>")]),t._v(" "),r("div",{attrs:{className:"mian"}},[t._v("这是 event 面")]),t._v(" "),r("NavLink",{attrs:{to:"/"}},[t._v("首页")]),r("br"),t._v(" "),r("NavLink",{attrs:{to:"/input"}},[t._v("表单")]),r("br"),t._v(" "),r("NavLink",{attrs:{to:"/event"}},[t._v("事件")]),t._v(" "),t._v("\n)\n}\n}\nexport default View;\n"),r("p",[t._v("常见问题\nMobX 是框架吗?\nMobX 不是一个框架。它不会告诉你如何去组织你的代码，在哪存储状态或者如何处理事件。然而，它可能将你从以性能的名义对你的代码提出各种限制的框架中解放出来。\nMobX\n简单、可扩展的状态管理")]),t._v(" "),r("p",[t._v("MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming – TFRP)使得状态管理变得简单和可扩展。MobX 背后的哲学很简单:")]),t._v(" "),r("p",[t._v("任何源自应用状态的东西都应该自动地获得。")]),t._v(" "),r("p",[t._v("其中包括 UI、数据序列化、服务器通讯，等等。")]),t._v(" "),r("p",[t._v("为什么使用 Mobx\nReact 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而 MobX 提供机制来存储和更新应用状态供 React 使用。")]),t._v(" "),r("p",[t._v("一些简单的 api 介绍\n1:状态 state")]),t._v(" "),r("p",[t._v("组件中的数据。")]),t._v(" "),r("p",[t._v("2:被观察 observable")]),t._v(" "),r("p",[t._v("被 observable 修饰的 state 数据将会暴露给整个 app，各观察者组件都可以根据 state 值的变化作出响应。")]),t._v(" "),r("p",[t._v("3:观察者 observer")]),t._v(" "),r("p",[t._v("被 observer 修饰的组件，将会根据组件内使用到的被 observable 修饰的 state 的变化而自动重新渲染（原理：用 autorun 包裹了 render 函数，state 变化触发 autorun 从而自动渲染）")]),t._v(" "),r("p",[t._v("4:action")]),t._v(" "),r("p",[t._v("state 值的修改需要在 action 函数中进行。")]),t._v(" "),r("p",[t._v("5:衍生值 computed")]),t._v(" "),r("p",[t._v("get：基于 state 值，通过一些计算得到的新值并返回给调用者。")]),t._v(" "),r("p",[t._v("set：get 的相反运算，参数为一个值，由该值进行 get 函数中的反运算，得到对应的 state 值并赋予 state。")]),t._v(" "),r("p",[t._v("6:衍生行为 autorun")]),t._v(" "),r("p",[t._v("基于 state 的变化而触发的一系列行为（注意：这些行为不改变 state 值、不产生新的数据），通常为日志记录、请求发送、UI 渲染等。")])],1)}),[],!1,null,null,null);e.default=o.exports}}]);